---
layout: post
title: "Pass@k is Mostly Bunk"

---
{{ page.title }}
================

<script>
  MathJax = {
    tex: {inlineMath: [['\\(', '\\)'], ['$', '$']]}
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<p class="meta">Exponentially better results? I'll take three!</p>

Measuring the success of AI agents isn't easy. It's very sensitive to what *success* means, it can require a lot of samples, its highly context sensitive. Generally hard. So it doesn't help that one of the most common metrics used for agents is (mostly) bunk. I'm talking about *pass@k*.

What is *pass@k*? It's the probability that at least one of *k* different attempts will succeed. A six-sided die, where *pass* means rolling a 6, has a pass@3 of 45% and a pass@10 of 83%. A D20 has a pass@25 of 72%, and a pass@100 of 99.4%.

99.4%! What a great evaluation result! Clearly the model is doing something meaningful and useful! No, it's doing something meaningful and useful 5% of the time.

The problem with pass@k is that's *exponentially* forgiving. There's a value of *k*, a fairly low one generally, that can make anything look good. Here's that six-sided die again:

<canvas id="passKGraph" width="400" height="300"></canvas>

Humans interacting with agents aren't nearly that forgiving. They, in general, aren't saying "well, I tried 10 times and it worked once, so I'm happy". They're saying "I tried 10 times and it only worked once, what a piece of junk". They're also doing multiple steps, and only happy when they all work. Exponentially unforgiving.

Why only *mostly* bunk? There are cases, where tasks are simple, evaluators are reliable, and humans are out of the loop, that the idea of getting exponentially better success rate with linear additional cost is good. I've made a similar argument about distributed systems [in the past](https://brooker.co.za/blog/2023/09/08/exponential.html). But these tasks aren't ubiquitous. Pass@k should be a metric that's rarely used, and carefully justified every time it is used.

If we're going to drive the field of agentic AI forward, we need to keep ourselves honest on metrics.

<script>
const canvas = document.getElementById('passKGraph');
const ctx = canvas.getContext('2d');
const p = 1/6;
const maxK = 20;
const padding = 40;
const graphWidth = canvas.width - 2 * padding;
const graphHeight = canvas.height - 2 * padding;

ctx.fillStyle = '#fff';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Draw axes
ctx.strokeStyle = '#000';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(padding, padding);
ctx.lineTo(padding, canvas.height - padding);
ctx.lineTo(canvas.width - padding, canvas.height - padding);
ctx.stroke();

// Draw grid and y-axis labels
ctx.strokeStyle = '#ddd';
ctx.lineWidth = 1;
ctx.fillStyle = '#000';
ctx.font = '12px sans-serif';
for (let i = 0; i <= 10; i++) {
  const y = canvas.height - padding - (i / 10) * graphHeight;
  ctx.beginPath();
  ctx.moveTo(padding, y);
  ctx.lineTo(canvas.width - padding, y);
  ctx.stroke();
  ctx.fillText((i * 10) + '%', 5, y + 4);
}

// Draw x-axis labels
for (let k = 0; k <= maxK; k += 5) {
  const x = padding + (k / maxK) * graphWidth;
  ctx.fillText(k, x - 5, canvas.height - padding + 20);
}

// Draw pass@k curve
ctx.strokeStyle = '#0066cc';
ctx.lineWidth = 2.5;
ctx.beginPath();
for (let k = 1; k <= maxK; k++) {
  const passK = 1 - Math.pow(1 - p, k);
  const x = padding + (k / maxK) * graphWidth;
  const y = canvas.height - padding - passK * graphHeight;
  if (k === 1) ctx.moveTo(x, y);
  else ctx.lineTo(x, y);
}
ctx.stroke();

// Labels
ctx.fillStyle = '#000';
ctx.font = '14px sans-serif';
ctx.fillText('k (number of attempts)', canvas.width / 2 - 60, canvas.height - 5);
ctx.save();
ctx.translate(15, canvas.height / 2);
ctx.rotate(-Math.PI / 2);
ctx.fillText('pass@k', 0, 0);
ctx.restore();
</script>

